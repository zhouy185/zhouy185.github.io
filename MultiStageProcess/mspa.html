<!DOCTYPE html>
<html>
<head>
    <title>Bottleneck Sim - Balanced Flow</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f4f7f6; display: flex; flex-direction: column; align-items: center; user-select: none; }
        
        .main-container { display: flex; flex-direction: column; align-items: center; gap: 15px; margin-top: 20px; }
        
        canvas { background: #ffffff; border: 1px solid #333; box-shadow: 0 4px 6px rgba(0,0,0,0.1); border-radius: 4px; }
        
        .controls { 
            display: flex; gap: 20px; align-items: center; 
            background: #e8eaf6; padding: 15px 25px; border-radius: 8px; border: 1px solid #c5cae9;
        }

        button {
            padding: 8px 20px; font-size: 14px; font-weight: bold; cursor: pointer;
            color: white; border: none; border-radius: 4px; transition: background 0.2s;
        }
        #toggleBtn { background-color: #34495e; min-width: 80px; }
        #toggleBtn:hover { background-color: #2c3e50; }
        #toggleBtn.paused { background-color: #27ae60; } 

        #resetBtn { background-color: #c0392b; }
        #resetBtn:hover { background-color: #a93226; }

        .slider-group { display: flex; flex-direction: column; align-items: center; width: 220px; }
        .slider-label { font-size: 13px; margin-bottom: 5px; font-weight: bold; color: #333; }
        input[type=range] { width: 100%; cursor: pointer; }

        .legend { display: flex; gap: 20px; font-size: 13px; color: #444; margin-top: 5px;}
        .legend span { display: flex; align-items: center; gap: 6px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
        .line { width: 3px; height: 16px; display: inline-block; background: #000; }
    </style>
</head>
<body>

    <div class="main-container">
        <h3>Worker-Paced System</h3>

        <canvas id="simCanvas" width="850" height="280"></canvas>

        <div class="controls">
            <button id="toggleBtn">Pause</button>

            <div class="slider-group">
                <span class="slider-label">Input Rate: <span id="speedVal" style="color:#d35400">1.0</span> units/sec</span>
                <input type="range" id="speedSlider" min="0.2" max="2.0" step="0.1" value="1.0">
            </div>

            <button id="resetBtn">Reset</button>
        </div>

        <div class="legend">
            <span><span class="line" style="background:black;"></span> Idle</span>
            <span><span class="line" style="background:#d32f2f;"></span> Busy</span>
            <span><span class="dot" style="background:gold; border:1px solid #333"></span> Processing</span>
            <span><span class="dot" style="background:#3498db; border:1px solid #333"></span> Waiting</span>
            <span><span class="dot" style="background:#2ecc71; border:1px solid #333"></span> Output</span>
        </div>
    </div>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const toggleBtn = document.getElementById('toggleBtn');
const resetBtn = document.getElementById('resetBtn');
const speedSlider = document.getElementById('speedSlider');
const speedVal = document.getElementById('speedVal');

// --- SIMULATION STATE ---
let isPaused = false;
let simTime = 0;
let units = [];
let finishedUnits = []; 
let lastSpawn = 0;

// Configuration
const STAGE_Y = 50;
const LINE_H = 150;
const UNIT_Y = 125;
const UNIT_RAD = 11;
const GAP = 26; 
const SPEED = 4;

// Default Rate: 1 unit/sec -> 1000ms interval
let spawnInterval = 1000;

const stages = [
    // FIX: Stage 1 is now 0.8s (800ms). 
    // This allows it to clear faster than the 1.0s input, preventing initial accumulation.
    { x: 100, time: 800, busyUntil: 0, name: "Stage 1 (1s) - Fast" },
    { x: 350, time: 3000, busyUntil: 0, name: "Stage 2 (3s) - Bottleneck" }, 
    { x: 600, time: 800, busyUntil: 0, name: "Stage 3 (1s) - Fast" }
];

// --- CONTROLS LOGIC ---

toggleBtn.onclick = () => {
    isPaused = !isPaused;
    toggleBtn.innerText = isPaused ? "Resume" : "Pause";
    toggleBtn.className = isPaused ? "paused" : "";
};

resetBtn.onclick = () => {
    units = [];
    finishedUnits = [];
    simTime = 0;
    lastSpawn = 0;
    stages.forEach(s => s.busyUntil = 0);
    draw(); 
};

// SLIDER LOGIC
speedSlider.oninput = (e) => {
    const rate = parseFloat(e.target.value); // Units per second
    speedVal.innerText = rate.toFixed(1);
    
    // Calculate Interval
    // Rate 0.5 -> 2000ms
    // Rate 1.0 -> 1000ms
    // Rate 2.0 -> 500ms
    spawnInterval = 1000 / rate; 
};

// --- SIMULATION LOGIC ---

class Unit {
    constructor() {
        this.x = 0;
        this.y = UNIT_Y;
        this.targetIdx = 0;
        this.state = 'moving';
        this.id = Math.random();
        this.basketOffset = { x: Math.random() * 60, y: Math.random() * 40 - 20 };
    }

    update() {
        // 1. Finished?
        if (this.targetIdx >= stages.length) {
            if (this.x < 740 + this.basketOffset.x) {
                this.x += SPEED;
            } else {
                return "done"; 
            }
            return true;
        }

        const stage = stages[this.targetIdx];
        let limit = stage.x;
        
        let unitAhead = units.find(u => u.targetIdx === this.targetIdx && u.x > this.x && u.id !== this.id);
        
        if (unitAhead) {
            let idealPos = unitAhead.x - GAP;
            // Floor Logic: Where did previous stage end?
            let prevStageX = (this.targetIdx === 0) ? 0 : stages[this.targetIdx - 1].x;
            
            // Allow stacking only if we hit the "floor" of the previous stage
            let floor = prevStageX + 25; 
            limit = Math.max(idealPos, floor);
        }

        if (this.state === 'processing') {
            if (simTime > stage.busyUntil) {
                this.state = 'moving';
                this.targetIdx++;
            }
        } else {
            // Movement
            if (this.x < limit) {
                this.x = Math.min(this.x + SPEED, limit);
            }

            // Check if at Stage
            if (Math.abs(this.x - stage.x) < 1) {
                if (simTime > stage.busyUntil) {
                    this.state = 'processing';
                    stage.busyUntil = simTime + stage.time;
                } else {
                    this.state = 'waiting';
                }
            } 
            // Check if at Queue Limit
            else if (Math.abs(this.x - limit) < 1) {
                this.state = 'waiting';
            }
        }
        return true;
    }

    draw() {
        ctx.beginPath();
        if (this.targetIdx >= stages.length) {
            ctx.fillStyle = "#2ecc71"; // Green (Done)
        } else if (this.state === 'processing') {
            ctx.fillStyle = "gold";
        } else {
            ctx.fillStyle = "#3498db"; // Blue
        }

        ctx.arc(this.x, this.y, UNIT_RAD, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.setLineDash([]); 
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 1;
        ctx.stroke();
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw Stages
    stages.forEach(s => {
        const isBusy = simTime < s.busyUntil;
        
        ctx.beginPath();
        ctx.setLineDash([]); 
        ctx.lineWidth = 4;
        ctx.strokeStyle = isBusy ? "#d32f2f" : "#000"; 
        
        ctx.moveTo(s.x, STAGE_Y);
        ctx.lineTo(s.x, STAGE_Y + LINE_H);
        ctx.stroke();

        ctx.fillStyle = "#333";
        ctx.textAlign = "center";
        ctx.font = "bold 14px Arial";
        ctx.fillText(s.name, s.x, STAGE_Y - 10);
        
        ctx.font = "11px Arial";
        ctx.fillStyle = isBusy ? "#d32f2f" : "#2e7d32";
        ctx.fillText(isBusy ? "PROCESSING" : "IDLE", s.x, STAGE_Y + LINE_H + 15);
    });

    // Draw Basket
    const basketX = 720;
    const basketY = 80;
    const basketW = 110;
    const basketH = 90;
    
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(basketX, basketY);
    ctx.lineTo(basketX, basketY + basketH);
    ctx.lineTo(basketX + basketW, basketY + basketH);
    ctx.lineTo(basketX + basketW, basketY);
    ctx.stroke();
    
    ctx.fillStyle = "#555";
    ctx.font = "14px Arial";
    ctx.textAlign = "center";
    ctx.fillText("Output Basket", basketX + basketW/2, basketY - 10);
    ctx.fillText("Total: " + (finishedUnits.length + units.filter(u=>u.targetIdx>=3).length), basketX + basketW/2, basketY + basketH + 20);

    // Draw Units
    finishedUnits.forEach(u => u.draw());
    units.forEach(u => u.draw());
    drawOverlaps();

    if (isPaused) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#333";
        ctx.font = "bold 24px Arial";
        ctx.textAlign = "center";
        ctx.fillText("PAUSED", canvas.width/2, canvas.height/2);
    }
}

function drawOverlaps() {
    const stacks = {};
    units.forEach(u => {
        if (u.state !== 'processing' && u.targetIdx < 3) {
            const key = Math.floor(u.x / 5) * 5; 
            if (!stacks[key]) stacks[key] = { count: 0, x: u.x, y: u.y };
            stacks[key].count++;
        }
    });

    for (const key in stacks) {
        const stack = stacks[key];
        if (stack.count > 1) {
            ctx.beginPath();
            ctx.arc(stack.x + 10, stack.y - 10, 9, 0, Math.PI * 2);
            ctx.fillStyle = "#c0392b";
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.stroke();
            ctx.fillStyle = "white";
            ctx.font = "bold 11px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(stack.count, stack.x + 10, stack.y - 10);
        }
    }
}

function loop() {
    if (!isPaused) {
        simTime += 16; 

        if (simTime - lastSpawn > spawnInterval) {
            units.push(new Unit());
            lastSpawn = simTime;
        }

        for (let i = units.length - 1; i >= 0; i--) {
            const res = units[i].update();
            if (res === "done") {
                finishedUnits.push(units.splice(i, 1)[0]);
            }
        }
    }

    draw();
    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);

</script>
</body>
</html>